<?xml version="1.0" encoding="utf-8"?>
<search>
  
    <entry>
      <title>เขียน Microservice ด้วย Node.js และ Seneca.js</title>
      <url>/backend/2018/01/18/seneca-nodejs-microservice/</url>
      <content type="text">
ในช่วง 2-3 ปีที่ผ่านกระแส Microservice ได้มาแรงมากๆ โดยที่ทำงานผมปัจจุบันแอพพลิเคชัน แอพเดียวนี่มี Microservice support อยู่หลังบ้านเป็น 10 ระบบแล้ว ดังนั้นถ้าผมไม่พูดถึงมันจะไม่เทรนนะจ๊ะ แต่จะไม่ลงรายละเอียดในส่วนของทฤษฎีเยอะนะครับเพราะมีพี่ๆ เขียนไว้เยอะแล้ว เรามันสายบู๊อยู่แล้วว่ะฮ่ะฮ่ะ

Microservice คืออะไร

Microservice คือแนวคิดการพัฒนาโปรแกรมแบบแยกโปรแกรมเป็นส่วนเล็กๆ ที่สามารถทำงานแยกออกจากกันได้มี environment แยกออกจากกัน แต่ก็สามารถทำงานร่วมกันได้เพื่อรวมกันกลายเป็นระบบที่ใหญ่ขึ้น ยกตัวอย่างเช่น ระบบธนาคาร (คลาสสิคสุดๆ) ในระบบธนาคารหนึ่งธนาคารก็จะมีระบบต่างๆ ประมาณนี้
	1. payment โอนเงิน / จ่ายเงิน
	2. balance จัดการยอดเงินผู้ใช้
	3. deposit ฝากเงิน
	4. sms แจ้งเตือนฝากถอน
	อันนี้คือตัวอย่างคร่าวๆ นะครับจากตัวอย่างเราจะเห็นว่าถ้าเป็นสมัยก่อนเขียนไว้ในระบบเดียวกัน (Monolithic) ซึ่งจะว่าดีก็ดีในแบบของเค้านะครับแต่ว่าเราจะไม่พูดเพราะก็คงรู้ๆ กันอยู่แล้ว ข้อเสียที่สำคัญของสถาปัตยกรรมลักษณะนี้คือ
	1. ถ้าระบบล่มจะล่มหมดเลย
	2. ทั้งทีมจำเป็นต้องถนัดเครื่องมือเดียวกันเช่น ถ้าใช้ Node.js ก็ต้อง Node.js ทั้งระบบ
	3. ดูแลรักษายาก
	นี่แค่ที่ผมคิดออกนะครับเพราะเหตุนี้แนวคิด Mircroservice จึงเกิดขึ้นเพื่อมาแก้ปัญหาของสถาปัตยกรรมแบบเก่าโดยเขียนระบบที่กล่าวมาข้างต้น แยกกันดังนี้
	1. payment โอนเงิน / จ่ายเงิน อย่างเดียวสายเปย์ ฐานข้อมูลก็เก็บแค่ transaction ที่โอนอย่างเดียว
	2. balance จัดการยอดเงิน วันๆทำแต่บัญชีอย่างเดียวไม่ต้องทำอะไรละ ฐานข้อมูลเก็บแค่ยอดเงินของผู้ใช้แต่ละคนพอ
	3. deposit ฝากเงิน ฝากเดียวจ้างกใครให้เงินมาเก็บๆ อย่างเดียวไม่สนใจอะไร ฐานข้อมูลก็เก็บแค่ transaction ที่ถอนอย่างเดียว
	4. sms แจ้งเตือนฝากถอนฟ้องอย่างเดียวจ้าใครฝากใครถอนโอนเงินให้ใครรู้หมดเก็บแค่ข้อมูล sms ที่ออกไปก็พอ
	จะเห็นว่าถ้าออกแบบสถาปัตยกรรมระบบในรูปแบบนี้จะช่วยแก้ปัญหาที่กล่าวมาข้างต้นได้ถ้าระบบใดระบบหนึ่งล่มระบบอื่นก็ยังสามารถทำงานอยู่ได้ เช่น โอนเงินล่ม แต่ก็ยังสามารถฝากเงินได้อยู่ดี ทีม balance อยากใช้ PHP ทีม sms จะใช้ node.js ก็ไม่มีปัญหาระบบไหนพังก็ดูแลเป็นระบบๆ ไป


ปัญหาของ Microservice


ถึง Microservice จะดูเทพมากมายขนาดไหนก็ยังมีปัญหาเรื่องความซ้ำซ้อนของระบบและการคุยกันระหว่าง service อยู่ดีเช่น การถอนเงินจากสถาปัตยกรรมของระบบข้างต้นถ้าผู้ใช้จะถอนเงินก็จะมี flow ประมาณนี้



จาก flow จะเห็นว่าเมื่อโอนเงินเสร็จระบบ payment ต้องส่งข้อความไปถึงสองครั้งเพื่อบอกระบบ sms กับ balance ว่าโอนเงินเสร็จแล้วนะ แล้วถ้าเกิดวันนึงอยากจะเพิ่มระบบ log เพื่อมาเก็บ transaction เข้าออกของทั้งระบบ แต่ละทีมก็ต้องไป implement เพิ่มเพื่อให้ส่งข้อความไปบอกระบบ log ว่าโอนแล้วนะ ฝากแล้วนะ ส่ง sms แล้วนะ อีกวุ่นวายเข้าไปใหญ่


แนวคิดของ Seneca.js


จากปัญหาข้างบนจึงมีคนคิดขึ้นมาได้ว่าถ้างั้นแทนที่เราจะส่งต้องข้อความไปบอกทีละ Microservice ว่าทำนั่นแล้วนะทำนี่แล้วนะ เราก็ให้ Microservice ของเราตะโกนไปว่าฉันทำเสร็จแล้วนะ ทีนี้ Microservice ตัวไหนที่รออยู่ก็สามารถรับข้อความไปได้เลยไม่ต้องไล่ส่งข้อความไปบอกทีละคนอยู่ ถ้าต่อไปมี Microservice อื่นที่ต้องใช้ข้อความนี้ก็เอามาประกอบได้เลยไม่ต้องไปแก้อันเก่าแค่รอรับข้อความก็พอ ซึ่งก็คือ Seneca.jsนั่นเอง Seneca.js เนี่ยเค้าบอกว่าตัวเองคือ


Seneca is a microservices toolkit for Node.js.
It helps you write clean, organized code that you can scale and deploy at any time.


แปลไทยก็ประมาณว่า seneca คือเครื่องมือที่ช่วยให้สถาปัตยกรรม Microservice ที่ implement ด้วย Node.js ชีวิตดีขึ้นว่างั้นเถอะ (สรุปเอาดื้อๆ) มันจะดีอย่างที่เค้าว่าหรือเปล่า ต่อไปเรามาลองใช้ Seneca.js กันนะครับ โดยเพื่อความสมจริง เราจะทำ Microservice 2 ตัวดังนี้ 
1. interface รับชื่อมาจาก Microservice
2. hello เอาชื่อมาส่งข้อความกลับไปว่า Hello ‘...'


Install


//interface service
mkdir interface
cd interface
npm init
npm install seneca express body-parser --save

//plus service
mkdir plus
cd plus
npm init
npm install seneca --save


Implement Seneca

//interface service
const app = require('express')(),
      seneca = require('seneca')();
                    
app.get('/', (req, res) =&amp;gt; {
   let name = req.query.name;
   seneca.client().act({service: 'hello', name: name}, (err, result) =&amp;gt; {
       if (err) return console.error(err)
       res.send(result.answer)
    });
})
app.listen(3000, function() {
    console.log('Listening on port: 3000');
});


จาก Code ข้างบนจะเห็นว่าก็ใช้ express ธรรมดาสิ่งที่อยากให้โฟกัสก็คือ


seneca.client().act({service: 'hello', name: name}, (err, result) =&amp;gt; {
	if (err) return console.error(err)
    res.send(result.answer)
});


คำสั่ง


seneca.client().act({service: 'hello', name: name}); 


คือการสั่งให้ seneca ตะโกนออกไปนะครับ ซึ่งค่าที่ส่งไปเป็นแบบ key-value


(err, result) =&amp;gt; {
    if (err) return console.error(err)
    res.send(result.answer)
});


คือการ handle สิ่งที่ตอบกลับมา ต่อมาเราจะมาดูในส่วนของ Microservice hello กันนะครับ


//hello service
const seneca = require('seneca')();
let hello = (msg, reply) =&amp;gt; {
    reply(null, {answer: ('Hello ' + msg.name)})
};

seneca.add('service:hello', hello).listen();

คำสั่ง 

seneca.add('service:hello', hello).listen(); 


คือการบอกให้รอฟังสิ่งที่ service อื่นตะโกนมานะครับโดยจะต้อง match กับ 'service:hello' เท่านั้นถึงจะทำงาน แล้วเราก็ส่ง function hello เข้าไปเพียงแค่นี้พอเราลองรัน service ทั้งสองตัวและเรียกไปที่ http://localhost:3000?name=noob ก็จะมี response ตอบกลับมาตามรูปนะจ๊ะ


หากต้องการ fix port, protocol, ip ก็สามารถทำได้ดังนี้ 

//interface service
.client({ port: 8080, host: '192.168.0.2',type: 'http' })
//hello service
.listen({ port: 8080, host: '192.168.0.2',type: 'http' })

นอกจากนี้ seneca.js ยังมีลูกเล่น และ plugin อีกเยอะแยะมากมายบรรยายไม่หมดเลยนะครับโดยสามารถเข้าไปดูเพิ่มเติมได้ที่ http://senecajs.org/

Conclusion


จากที่ลองใช้งานดู seneca.js เป็นเครื่องมือที่สามารถประยุกต์ใช้งานได้หลากหลายมากๆ แล้วแต่ว่าจะเอาไปทำอะไร ไม่ว่าเป็น healthcheck, log system, แชร์ config, แชร์ library ระหว่าง service, ส่ง message ไปหา service อื่น, etc. เรียกว่าของมันต้องมี เชื่อผมเถอะแล้วชีิวิตจะง่ายขึ้น! เหมือนเดิมครับตัวอย่าง code สามารถดูได้ ที่นี่ ถ้าชอบก็อย่าลืมกดไลค์กดแชร์ด้วยนะครับบ จุ๊บปาก &amp;lt;3

</content>
      <categories>
        
          <category> backend </category>
        
      </categories>
      <tags>
        
          <tag> node.js </tag>
        
          <tag> microservice </tag>
        
          <tag> javascript </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>เขียน RESTful API ใน Node.js แบบ 'โคตรไว' ด้วย Loopback</title>
      <url>/backend/framework/2017/12/04/loopback-nodejs-framework/</url>
      <content type="text">
เนื่องจากผมได้มีโอกาศไปรับงานนึงเกี่ยวกับการจัดการ Stock สินค้าซึ่งจาก Scale งานเนี่ยน่าจะใช้เวลาพัฒนาประมาณ 2 อาทิตย์แต่ลูกค้าแบบว่าเร่งมากบอกน้องพี่ขอ 7 วันได้ไหม!! แม่เจ้าาาา รีบไปไหนเนี่ยพ่อคู๊ณณ แต่ถือเป็นโชคดีที่ก่อนหน้าที่ทำงานของผมได้ให้ผมทำ research เกี่ยวกับ node.js framework ตัวนึงชื่อว่า loopback ซึ่งหลังจากได้ลองใช้ขอบอกเลยว่ามันดีมากเลยอ่ะแกรร แบบว่าของมันต้องใช้อ่ะแกรร ว่าแล้วเราก็มาลองใช้งานกันเลยเถอะ


    loopback คือ Node.js framework สำหรับสร้าง REST API อย่างรวดเร็วพร้อมเครื่องมือสำหรับสร้าง Model พร้อม validation และอื่นๆ อีกมากมายอย่างครบวงจรเรียกได้ว่าช่วยประหยัดเวลาในการพัฒนาเป็นอย่างมาก โดย ขั้นตอนการใช้ loopback เบื้องต้นมีดังนี้


Setup

สำหรับเริ่มใช้งานก็แบบชิลๆ เปิด terminal ขึ้นมา และพิมพ์คำสั่งดังนี้

npm install -g loopback-cli
lb

เมื่อพิมพ์คำสั่งตามนี้จะปรากฏหน้าต่างให้ setup ข้อมูล api ดังนี้

What's the name of your application?  hello-loopback (ชื่อของ api)
Enter name of the directory to contain the project: hello-loopback (ไฟล์ต่างๆไว้ในโฟรเดอร์ชื่ออะไรถ้าไม่ใส่จะใส่ในไดเร็กทอรี่เดียวกับชื่อ  api)
Which version of LoopBack would you like to use? เวอร์ชันของ loopback ในที่นี้เลือกเวอร์ชัน 3.x
What kind of application do you have in mind? เลือกค่าพื้นฐานของ api ในที่นี้เลือก empty-server


เมื่อใส่รายละเอียดต่างๆ เสร็จแล้ว loopback จะทำสร้างไฟล์ต่างๆ ตามที่เรา setup ไว้เป็นอันเสร็จขั้นตอนแรก

Create Model

เมื่อเรา setup เสร็จแล้วเราก็จะมาสร้าง model แรกกันโดยมีขั้นตอนดังนี้

cd hello-loopback
lb model

เมื่อเราพิมพ์คำสั่ง lb model บรรทัดแรกจะขึ้นตัวแดงๆ มาไม่ต้องตกใจบรรทัดต่อมามันจะถามว่า

Enter the model name: blog (ให้เราใส่ชื่อ model ของเรา)
Select model's base class: PersistedModel (เลือกประเภทของ model ที่เราจะสร้าง)
Expose blog via the REST API? Y (model นี้เป็น REST api หรือเปล่า)
Custom plural form: /blog (path ของ model นี้)
Common model or server only? common (model นี้จะเอาไว้ที่ไหนในไดเรคทอรี่ server หรือ common)


เมื่อ setup model เสร็จมันก็จะให้เราใส่ property ของ model โดยมีรายละเอียดดังนี้

Property name: name (ชื่อของ property)
Property type: string (ประเภทของ property)
Required? Y (จำเป็นต้องใส่หรือไม่)
Default value[leave blank for none]: (ค่า default ของ property นี้)


เมื่อเราใส่ property เสร็จมันก็จะวนถามใหม่เรื่อยๆ ให้เราใส่เรื่อยๆ จนกว่าจะพอใจเมื่อพอใจแล้วตรง Property name: ให้เว้นว่างไว้มันก็จะออกจากการสร้าง model
เมื่อเราเข้าไปดูในไดเรคทอรี่ common/models ก็จะเห็นไฟล์ชื่อ model ของเรา 2 ไฟล์คือ .js (จะอธิบายต่อไป) และ .json เก็บข้อมูลต่างๆ ของ model เรา

Connect database

เมื่อเราสร้าง model เสร็จแล้วสิ่งที่เราต้องทำต่อมาคือเชื่อมต่อกับฐานข้อมูลซึ่งสามารถทำได้โดยพิมพ์คำสั่ง 

lb datasource

หลังจากนั้นมันจะขึ้นคำถามดังนี้

Enter the datasource name: mysql (ให้ใส่ชื่อ datasource อะไรก็ได้)
Select the connector for mysql: MySQL (ให้เลือกฐานข้อมูลในที่นี้ใช้ MySQL)
Connection String url to override other settings (eg: mysql://user:pass@host/db): mysql://root@127.0.0.1/test (ใส่รายละเอียดการเชื่อมต่อไม่ต้องใส่ก็ได้)
host: 127.0.0.1 (ใส่ host ของฐานข้อมูล)
port: 3306 (ใส่ port สำหรับเชื่อมต่อฐานข้อมูล)
user: root (ใส่ username)
password: (ใส่ password)
database: test (ใส่ฐานข้อมูลที่ต้องเชื่อมต่อ)
Install loopback-connector-mysql@^2.2: Y (ต้องการติดตั้ง loopback-connector-mysql หรือไม่)


หลังจากนั้นไปที่ไฟล์ server/model-config.js แก้ตรง

...
datasource: null
...


เป็น

...
datasource: ‘mysql’ (ชื่อของ datasource ที่เราสร้างขึ้น)
...

เพียงเท่านี้ก็เสร็จเรียบร้อยในขั้นตอนการเชื่อมต่อกับฐานข้อมูลแล้วต่อไปเราก็จะมาสร้างตารางจาก model ของเรากัน

Automigrate

เมื่อเรามี model แล้ว เชื่อมต่อฐานข้อมูลแล้ว ต่อมาเราก็จะทำการสร้างตารางสำหรับ model ของเรากันโดยเปิด editor ขึ้นมาแล้วสร้างไฟล์ชื่ออะไรก็ได้ใส่ไว้ในไดเรคทอรี่ server/boot โดยใส่ code ดังนี้

module.exports = (app) =&amp;gt; {
	app.dataSources.mysql.automigrate('blog', (err) =&amp;gt; {
		if (err) throw err;
		app.models.blog.create([{
			name: 'test1',
			author: 'mike',
			date: Date()
		}, {
			name: 'test2',
			author: 'mike',
			date: Date()
		}, {
			name: 'test3',
			author: 'mike',
			date: Date()
		}, ], (err, blog) =&amp;gt; {
			if (err) throw err;
			console.log('Models created: \n', blog);
		});
	});
};

code ด้านบนอธิบายได้ดังนี้

app.dataSources.mysql.automigrate('blog', (err) =&amp;gt; {
  ...
});

เป็นฟังชันสำหรับ migrate ฐานข้อมูลของ loopback โดยส่ง parameter เข้าไปสองตัวคือ model ที่ต้องการ migrate และ callback

app.models.blog.create([{
	name: 'test1',
	author: 'mike',
	date: Date()
},
        ...
]);

คือการเพิ่มข้อมูลใส่ในตารางที่เราทำการ migrate ** มีข้อควรระวังคือหากในตารางนั้นมีข้อมูลอยู่แล้วจะถูกเขียนทับ **

...
(err, blog) =&amp;gt; {
	if (err) throw err;
	console.log('Models created: \n', blog);
}
...

คือการ handle callback เมื่อทำการ migrate สำเร็จ หลังจากนั้นเมื่อเราเตรียมทุกอย่างพร้อมเราจึงเริ่มทำรัน REST api ของเราโดยพิมพ์คำสั่ง

node .

เมื่อเข้าไปดูในฐานข้อมูลก็จะพบตารางชื่อตาม model ของเราโดยที่มีข้อมูลตามที่เรา insert เข้าไปดังภาพ


ทดลองใช้ API

หลังจากที่เรารัน REST api แล้วให้ลองเปิด browser เข้าไปที่ path 127.0.0.1:3000/explorer จะพบหน้าตาสำหรับทดลอง api ดังภาพ

หากเราต้องเพิ่มข้อมูลเข้าสู่ตารางให้เลือกที่ post ใส่ข้อมูลลงไป และกดที่ try out ดังภาพ

หลังจากนั้นเมื่อเราเข้าไปดูที่ฐานข้อมูลก็จะเห็นข้อมูลที่เราเพิ่มไปเมื่อกี้เข้ามา

หรือหากลองเปิด Browser แล้วเข้าไปที่ http://localhost:3000/api/blog ก็จะเห็นข้อมูลในฐานข้อมูลเราดังภาพเพียงแค่นี้เราก็สร้าง RESTful API สำหรับ CRUD เสร็จแล้วนะครับต่อไปเราจะมาทำ Custom API กัน


Custom API

เพราะในชีวิตจริง API เราของไม่ได้มีแต่ CRUD ต้องฟังชันการทำงานอื่นๆ ซึ่งใน loopback เนี่ยเราสามารถทำ API เอกได้ง่ายๆดังนี้เปิดไฟล์ Model ของเราขึ้นมาซึ่งไฟล์ Model ของเราจะอยู่ที่ common/models/ชื่อโมเดล.js ซึ่งพอเราเปิดขึ้นมาก็จะเป็นไฟล์ไม่ได้ทำๆ (ไฟล์เปล่าๆ) ที่มีข้อมูลหล่อมแหล่มดังนี้

'use strict';

module.exports = function(Blog) {

};

ให้เราสอดใส่ Code เข้าไปดังนี้

module.exports = function(Blog) {

	Blog.hello = function(msg, callback){
		callback(null, &quot;Hello &quot;+msg)
	}
	Blog.remoteMethod(
		'hello', {
			http: {
				path: '/hello',
				verb: 'get'
			},
			accepts: {
				arg: 'msg', 
				type: 'string'
			},
			returns: {
				arg: 'word',
				type: 'string'
			}
		}
	);
};

Code ข้างบนมีการทำงานคือเมื่อมีคน route ผ่าน method get มาที่ http://localhost:3000/api/blog/hello พร้อม parameter ชื่อ msg ก็จะตอบกลับดังรูปตัวอย่าง

โดย Code ข้างบนมีการทำงานดังนี้

module.exports = function(Blog) {
...
};

export module ของเราส่วน Parameter Blog ที่เข้ามาก็คือ model ของเราพร้อมฟังก์ชันเสริมต่างๆ นาๆที่ loopback เพิ่มมาให้

Blog.hello = function(msg, callback){
	callback(null, msg)
}

เพิ่มฟังชันชื่อ hello เข้าไปใน model Blog โดยที่ parameter ที่ส่งเข้าไปตัวแรก msg คือค่าที่รับมาจาก request และ callback นี่ loopback ส่งเข้ามาให้เราสำหรับส่งข้อมูลกลับไปเมื่อเราทำงานเสร็จแล้ว จะสังเกตุเห็นว่าใน loopback รับ parameter 2 ตัว ตัวแรกที่เป็น null คือerr ในกรณีที่มี err ตัวที่สองคือค่าที่เราจะ response ออกไป

Blog.remoteMethod(
    'hello', {
        http: {
            path: '/hello',
            verb: 'get'
        },
        accepts: {
            arg: 'msg', 
            type: 'string'
        },
        returns: {
            arg: 'word',
            type: 'string'
        }
    }
);

คือการตั้งค่า Custom API ของเรา 

'hello', {
...
}

คือบอกว่าตั้งค่าของฟังก์ชันไหน

...
http: {
	path: '/hello',
	verb: 'get'
},
...

คือการเซ็ทพาท และ method ที่เข้ามา

...
accepts: {
	arg: 'msg', 
	type: 'string'
},
...

คือการเซ็ท parameter ที่จะเข้ามา arg คือชื่อ type คือประเภท

...
returns: {
	arg: 'word',
	type: 'string'
}
...

คือการเซ็ทข้อมูล response ที่จะออกไปก็เหมือนเดิมครับ arg คือชื่อ และ type คือประเภท

Conclusion

เป็นอันเสร็จเรียบร้อยแล้วนะครับสำหรับการใช้ loopback สร้าง RESTful API เบื้องต้นในตอนต่อไป (ถ้าไม่ลืม) จะมาสอนใช้งาน loopback ร่วมกับ Angular 2 กันนะจ๊ะจุ๊ปปาก &amp;lt;3 สามารถดูตัวอย่าง source code ได้ ที่นี่ นะจ๊ะ
</content>
      <categories>
        
          <category> backend </category>
        
          <category> framework </category>
        
      </categories>
      <tags>
        
          <tag> node.js </tag>
        
          <tag> javascript </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>วิธีใช้ knex.js จัดการฐานข้อมูล MySQL ใน Node.js</title>
      <url>/backend/database/library/2017/11/29/knex-nodejs-orm/</url>
      <content type="text">
ด้วยในยุคนี้นะครับเป็นยุคที่ Javascript ครองเมืองหันไปทางไหนก็มีแต่ Javascript เต็มไปหมดเลยครับไม่ว่าจะ React, Angular, Vue, Node, MEAN โอ้ยยเยอะแยะไปหมด หลายๆที่ก็เริ่มเปลี่ยนฝั่ง Back จาก PHP มาเป็น Node.js และฝั่ง Front ก็เริ่มเป็น Angular, Vue, React อะไรก็ว่า แต่เขียนโค้ดใหม่ที่ว่ายากแล้วการต้อง migration ข้อมูลจาก MySQL ไปเป็นฐานข้อมูลแบบ NoSQL สถาปัตยกรรมมันเข้ากันก็ลำบากเหลือเกิน ครั้นจะเขียน SQL คิวรี่เหมือนเดิมก็ขัดใจ๋ขัดใจ การเขียนโปรแกรมแบบ ORM (Object Relational Mapping) จึงเกิดขึ้น การเขียนโปรแกรมแบบ ORM พูดง่ายๆก็คือการแปลงข้อมูลที่ไม่เป็น Object มาอยู่ในรูป Object สำหรับใช้ภาษาโปรแกรมที่เป็น Object Oriented ซึ่งในบทความนี้เราจะใช้ ORM Tool ชื่อว่า
knexjs.org นั่นเอง&amp;lt;/p&amp;gt;

ORM คือการแปลงข้อมูลที่ไม่เป็น Object มาอยู่ในรูป Object สำหรับใช้ภาษาโปรแกรมที่เป็น Object Oriented
หมายเหตุในบทความนี้ใช้ async / await เยอะมากเพื่อความเข้าใจกรุณาไปศึกษาเรื่องนี้มาก่อนนะจ๊ะ

What is knex.js

knex.js คือเครื่องมือที่ช่วยให้เราเขียน node.js สามารถจัดการกับฐานข้อมูลในรูปแบบ Object ได้ (ORM) ทำให้เราเขียนโปรแกรมได้ง่ายขึ้นเพราะไม่ต้องมาคอยเขียนคำสั่ง SQL และแปลงข้อมูลที่ได้มาให้เป็น Object ของเราอีกทีนึงให้วุ่นวาย ขั้นตอนการใช้งานมีดังนี้

Setup

เอาละครับเรารู้จัก ORM กับ knex.js กันคร่าวๆ แล้วเรามาลงมือทำกันเลยดีกว่าเปิด terminal ขึ้นมาแล้วพิมพ์ตามนี้

mkdir test-knex 
cd test-knex
npm init
npm install -–save knex mysql

ขั้นตอนแรกสร้างโฟลเดอร์ขึ้นมาแล้วติดตั้ง Module ต่างๆที่จำเป็นดังนี้ knex และ mysql

Connect Database

ต่อไปเรามาสร้าง CRUD จาก knex กันนะครับโดยขั้นตอนแรกให้เพิ่มทำการ connect ฐานข้อมูลก่อนดังนี้

this.knex = knex({
    client: 'mysql',
    connection: {
        host : '127.0.0.1',
        user : 'root',
        password : '',
        database : 'knex'
    }
});

บรรทัดนี้เป็นการเชื่อมต่อกับฐานข้อมูลนะครับโดยใส่รายละเอียดต่างๆ เข้าไป client คือบอกว่าเราใช้ฐานข้อมูลประเภทอะไรส่วน connection ก็คือรายละเอียดทั่วๆไปของฐานข้อมูล

Do table Job

ก่อนที่เราจะสร้าง CRUD ได้ เราจำเป็นต้องมีตารางสำหรับทดสอบก่อนโดยเราสามารถจัดการกับตารางได้โดยใช้คำสั่งต่อไปนี้

await this.knex.schema.dropTableIfExists('Blog');
await this.knex.schema.createTableIfNotExists('Blog', (tbl) =&amp;gt; {
    tbl.increments('id').primary().unique().index();
    tbl.string('name');
    tbl.string('writer');
});

คำสั่งข้างล่างนี้
this.knex.schema.dropTableIfExists('Blog');
คือการ Drop ตารางถ้าหากว่ามีตารางนี้แล้ว เทียบได้กับ คำสั่ง

 DROP TABLE IF EXIST ‘Blog’
ใน MySQLและ 

this.knex.schema.createTableIfNotExists('Blog', (tbl) =&amp;gt; {
	...
}); 

คือคำสั่งสำหรับตารางถ้ายังไม่มี

tbl.increments('id').primary().unique().index();
tbl.string('name');
tbl.string('writer');

คือการ set structure ให้ตาราง Blog โดยเทียบได้กับคำสั่ง

CREATE TABLE IF NOT EXISTS ‘Blog’ (‘id’ INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
‘name’ VARCHAR(255), ‘writer’ VARCHAR(255));

ซึ่ง data type ใน knex มีครอบคลุมทุกประเภทใน MySQL โดยสามารถดูเพ่ิมเติมได้ที่ knexjs.org

CREATE


ต่อมาเรามาเริ่ม insert ข้อมูลชุดแรกลงฐานข้อมูลกัน โดยการ insert ข้อมูลของ knex มี 2 แบบคือ แบบธรรมดา และ แบบ Batch สำหรับ insert ข้อมูลจำนวนมาก
	ตัวอย่างคำสั่ง insert ข้อมูลธรรมดา
    
await this.knex('Blog').insert({name: 'lonely insert', writer: 'lonely man'});

	เทียบได้กับ

INSERT INTO Blog (‘name’, ‘writer’) VALUES (‘lonely insert’,’lonely man’);

	หาต้องการ insert ID ให้เอาตัวแปลไปรับได้เลย เช่น 

let id = await this.knex('Blog').insert({name: 'lonely insert', writer: 'lonely man'});

	ตัวอย่างคำสั่ง insert ข้อมูลแบบ Batch สำหรับ insert ข้อมูลจำนวนมาก

await this.knex.batchInsert('Blog',[{
        name: 'hello world',
        writer: 'mike'
    },{
        name: 'hello awesome',
        writer: 'nun'
    },{
        name: 'this is awesome lib',
        writer: 'mike'
}]);

	เทียบได้กับ

INSERT INTO Blog (‘name’, ‘writer’) VALUES (‘hello world’,’mike’),(‘hello awesome’, ’nun’),(‘this is awesome lib’, ‘mike’);



READ


	เมื่อเรา insert  ข้อมูลลงฐานข้อมูลเสร็จแล้วต่อมาเราจะทำการอ่านข้อมูลจากฐานข้อมูลซึ่งเราสามารถทำได้โดยใช้คำสั่งดังนี้

let data = await this.knex('Blog').select();

	เทียบได้กับ

SELECT * FROM Blog

	หรือหากต้องการใส่เงื่อนไขในการคิวรี่ข้อมูลก็สามารถทำได้ดังนี้

let data = await this.knex('Blog').where({writer: 'mike'}).select();

	เทียบได้กับ

SELECT * FROM Blog WHERE writer = ‘mike’

	นอกจากนี้คำสั่งที่ใช้การคิวรี่อื่นๆ เช่น JOIN, COUNT, SUM, GROUP BY และอื่นๆ knex ก็รองรับนะครับโดยสามารถดูตัวอย่างการใช้งานได้ที่นี่นะครับ 
    knexjs.org


UPDATE


READ เสร็จแล้วต่อมาก็คือ UPDATE ซึ่งใน การ UPDATE ก็สามารถทำได้ดังนี้

await this.knex('Blog').where({writer: 'lonely man'}).update({name: 'not alone insert'});

 เทียบได้กับ

UPDATE Blog SET name = 'not alone insert' WHERE writer = 'lonely man'



DELETE


	สุดท้ายแล้วนะครับเมื่อเรา CREATE READ UPDATE จนหนำใจแล้วพอเราเริ่มเบื่อเราก็ลบมันทิ้งโดยใช้คำสั่งดังนี้

await this.knex('Blog').where({writer: 'mike'}).del();

เทียบได้กับ

DELETE from Blog WHERE writer = 'mike'



Conclusion

หมดแล้วครับสำหรับบทความนี้ก็สั้นหน่อยนะครับเพราะแอบเขียนในที่ทำงานแหะๆ เหมือนเดิมครับ source code อยู่บน Github ตามลิงค์นี้นะจ๊ะ
Github
&amp;lt;/p&amp;gt;
</content>
      <categories>
        
          <category> backend </category>
        
          <category> database </category>
        
          <category> library </category>
        
      </categories>
      <tags>
        
          <tag> node.js </tag>
        
          <tag> javascript </tag>
        
          <tag> MySql </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>วิธีทำ Notification(แจ้งเตือน) ให้ Ionic2 ด้วย Firebase และ Node.js</title>
      <url>/mobile/2017/03/28/ionic2-notification/</url>
      <content type="text">
สวัสดีครับหลังจากคราวก่อนได้เขียนวิธีสร้าง แอพพลิเคชันแชทแบบง่ายๆ ด้วย Ionic2 Node.js ก็มีคนบอกว่าอยากให้เขียนวิธีการแจ้งเตือนให้มือถือและผมก็คิดเรื่องจะเขียนไม่ออกด้วยครับช่วงนี้เพราะฉะนั้นวันนี้ีเราทำแจ้งเตือนกันเถอะ 555 โดยแจ้งเตือนเนี่ยมี 2 แบบคือแบบ Local Notification และไม่ Local โดยจะแตกต่างกันดังนี้


Local Notification (เกมเตือนให้รับของประจำวัน) ไม่จำเป็นต้องมี Server เป็นการตั้งค่าให้แจ้งเตือนตามเวลาที่ตั้งไว้ข้อดีคือง่ายแต่มีข้อเสียคือข้อมูลจะตายตัวไม่มีการเปลี่ยนแปลง (ไว้บทความถัดไปนะจ๊ะ)
ไม่ Local (facebook, line) จำเป็นต้องมี Server เพื่อส่งแจ้งเตือนให้แอพพลิเคชันมีข้อดีคือสามารถแจ้งเตือนเมื่อไหร่ก็ได้ข้อมูลสามารถยืดหยุ่นตาม Server ส่งมาให้ (สอนในบทความนี้)

แจ้งเตือนที่มีข้อมูลแบบไม่ตายตัว(app แชททั่วไป) ต้องมี server แจ้งเตือนแบบตายตัว(เช่น เกมเตือนให้รับของประจำวัน) ไม่จำเป็นต้องมี server

Required &amp;amp; Install

สิ่งที่จะใช้ในการทำแจ้งเตือนของบทความนี้มีดังนี้

    Node.js เวอร์ชันล่าสุด
    gmail (คิดว่าทุกคนคงจะมีนะจ๊ะ)
    มือถือ Android (ใช้ทดสอบ)
    ในการทดสอบโทรศัพท์มือถือและคอมเครื่องที่ใช้เป็น server ต้องต่อเน็ตวงเดียวกันนะจ๊ะ (Wifi อันเดียวกัน)


Init Firebase

ขั้นแรกให้เราเปิดเว็ปไซด์ Firebase ขึ้นมาพร้อม Login ให้เรียบร้อยหากยังไม่มีโปรเจคให้สร้างโปรเจคด้วยนะครับ

สร้างโปรเจคขึ้นมาใน Firebase
หลังจากนั้นกดเข้ามาใน Project และไปที่ Project Settings &amp;gt; Cloud Messaging จะเห็นหน้าจอแบบภาพข้างล่างนะครับให้จดเลข Server Key และ Sender ID ไว้นะจ๊ะ

จด Server Key กับ Sender ID ไว้ให้ดีนะจ๊ะต้องใช้

    Server Key ใช้สำหรับใส่ใน Server ของเรา
    Sender ID ใช้สำหรับใส่ในแอพของเรา


Start Server

เมื่อเราตั้งค่า Firebase เสร็จแล้วต่อไปเรามาเริ่มสร้าง Server สำหรับส่งแจ้งเตือนกันนะจ๊ะ

    mkdir ionic-notification
    cd ionic-notification
    npm init
    npm install node-gcm express --save

node-gcm ใช้สำหรับส่งแจ้งเตือนนะครับส่วน express ใช้เป็น server
index.js

const express = require('express');
const gcm = require('node-gcm');
const bodyParser = require('body-parser');
const app = express();
app.use( bodyParser.json() );

const server_key = 'XXXXXXXXXXX'; // server key

var send = (token) =&amp;gt; {
  let retry_times = 3;
  let sender = new gcm.Sender(server_key);
  let message = new gcm.Message();
  message.addData('title', 'Hello Lady~!');
  message.addData('message', 'Hello Beutiful Girl!');
  sender.send(message, token, retry_times, (result) =&amp;gt; {
    console.log('send noti!');
  }, (err) =&amp;gt; {
    console.log('cant send noti T^T');
  })
}

app.get('/', (req, res) =&amp;gt; {
    res.send(&quot;This is basic route&quot;);
});


app.post('/open', (req, res) =&amp;gt; {
  /*insert token to DB*/
  let token = req.body.token.registrationId;
  console.log(JSON.stringify(token));
  send(token);
})

app.get('/send', (req, res) =&amp;gt; {
  let token = 'XXXXXXXXXXXXX'; //token
  send(token);
  res.send(&quot;send notification&quot;);
})

app.listen(5555, () =&amp;gt; {
    console.log('Program running on port : 5555');
});

เรียบร้อยครับสั้นดีใช่ไหมครับสำหรับ Code ฝั่ง Server ของเราต่อไปอธิบาย Code นะครับ

const express = require('express');
const gcm = require('node-gcm');
const bodyParser = require('body-parser');
const app = express();
app.use( bodyParser.json() );

const server_key = 'XXXXXXXXXXX'; // server key

เรียกใช้งาน Module ที่จำเป็นนะครับ node-cgm ใช้ส่งแจ้งเตือนส่วน bodyParse ใช้แปลงค่า input ที่ส่งผ่าน Post มานะครับ และสุดท้ายสร้าง server โดยใช้ express นะครับ ตรง server_key ให้ใส่ server_key ที่เราจดมาตะกี้ลงไปนะครับ (อันที่ยาวๆอ่ะ)

app.get('/', (req, res) =&amp;gt; {
    res.send(&quot;This is home page&quot;);
});

app.post('/open', (req, res) =&amp;gt; {
  ...
})

app.get('/send', (req, res) =&amp;gt; {
  ...
})
app.listen(5555, () =&amp;gt; {
    console.log('Program running on port : 5555');
});

app.get ต่างๆคือการ route นะครับว่าเข้ามาผ่าน url นี้ให้ทำอะไรส่วน app.listen คือให้เริ่มทำงานที่ port ไหน

 เข้ามาผ่าน / ให้ตอบกลับไปว่านี่คือ Home Page นะย๊ะ 
 /open รับ token เข้ามาผ่าน Post /open จริงๆตรงนี้ให้เราเก็บข้อมูล token เข้าสู่ฐานข้อมูลเพื่อใช้แจ้งเตือนในโอกาศต่อไป
 /send เมื่อมีการส่ง Get เข้ามาผ่าน /send ให้ส่งแจ้งเตือนไปตาม token ที่เรากับไว้ในฐานข้อมูล


  let retry_times = 3;
  let sender = new gcm.Sender(server_key);
  let message = new gcm.Message();
  let token = req.params.token;
  message.addData('title', 'Hello Lady~!');
  message.addData('message', 'Hello Beutiful Girl!');

เตรียมตัวแปรสำหรับส่งแจ้งเตือน

retry_times ถ้าส่งไม่สำเร็จจะให้ลองส่งใหม่กี่ครั้งสำหรับลูกผู้ชายอย่างผมให้โอกาศใครไม่เกิน 3 ครั้ง
sender สร้าง sender ใช้สำหรับส่งแจ้งเตือน
message สร้างข้อความสำหรับส่งไปให้มือถือของเรา
token รหัสของมือถือที่มีการเชื่อมต่อเข้ามา
message.addData ตั้งค่าต่างๆของ message เช่น หัวข้อ ข้อความ เสียงเป็นต้น


sender.send(message, token, retry_times, (result) =&amp;gt; {
    console.log('send noti!');
    res.send('you get message');
  }, (err) =&amp;gt; {
    console.log('cant send noti T^T');
    res.send('cant send message');
  })

sender.send ส่งแจ้งเตือนไปที่มือถือเมื่อทดสอบรันด้วยคำสั่งข้างล่างนี้เป็นอันเสร็จนะแจ๊ะ

  node index.js
  Program running on port : 5555


Start Ionic

เอาล่ะไม่ต้องบรรยายมากมาเริ่มกันเตอะ

ionic start ionic-notification-client blank --v2
cd ionic-notification-client
ionic platform add android
cordova plugin add phonegap-plugin-push --variable SENDER_ID=&quot;XXXXXXX&quot;
npm install --save @ionic-native/push

SENDER_ID คือ id ที่ได้มาจาก Firebase ตอนแรกนะครับ(อันสั้นๆ) ต่อมาให้เปิดไฟล์ src/app/app.module.ts เพิ่ม Push เข้าไปใน Provider ตามข้างล่างนี้

    providers: [Push, ... ]

ต่อมาเราเปิดไฟล์ src/app/app.component.ts เพิ่ม Code ดังนี้เข้าไป

import { Push, PushObject, PushOptions } from '@ionic-native/push';
import { Http } from '@angular/http';

import module ที่ต้องการใช้โดยมีรายละเอียดดังนี้

Push, PushObject, PushOptions ใช้สำหรับส่ง Notification ไปที่มือถือ
Http สำหรับส่ง Http ไปที่ Server ของเรา


constructor(
    ..., 
    private push: Push
) 

ประกาศตัวแปร private ชื่อ push โดยนำค่ามาจาก Module Push (ที่ import มาข้างบนอ่ะ)

constructor(
    ...
){
    platform.ready().then(() =&amp;gt; {
      ...
      this.initPushNotification();
    });
}

เรียกใช้ฟังชันชื่อ initPushNotification เมื่อแอพพร้อมทำงาน

initPushNotification(){
    const options: PushOptions = {
       android: {
           senderID: '492553210615',
           sound: true,
           vibrate: true
       }
    };
    const pushObject: PushObject = this.push.init(options);

    pushObject.on('registration').subscribe(
      data =&amp;gt; {
        this.http.post('http://192.168.1.11:5555/open',{token: data}).subscribe(res =&amp;gt; {
              console.log('register send');
        });
    });
    pushObject.on('notification').subscribe(
      notification =&amp;gt; {
        alert('You are in app');
      });
  }

สร้างฟังชันชื่อ initPushNotification สำหรับรับและส่งแจ้งเตือน หมายเหตุ http://192.168.1.11 ให้ใส่เป็น ip  เครื่องตัวเองนะจ๊ะ

const options: PushOptions = {
       android: {
           senderID: '492553210615',
           sound: true,
           vibrate: true
       }
    };

เตรียมค่า option ต่างๆสำหรับการแจ้งเตือน

senderID รหัสที่ได้มาจาก Firebase (รหัสเดียวกับตอนที่ add plugin อันสั้นๆ)
sound ตั้งค่าเสียง
vibrate ตั้งค่าสั่น


const pushObject: PushObject = this.push.init(options);

ตั่งค่า option สำหรับแจ้งเตือน

pushObject.on('registration').subscribe(
  data =&amp;gt; {
    ...
  }
);

เป็น event ที่เกิดขึ้นเมื่อเปิด app โดยจะ return data ซึ่งมี token ของมือถือเครื่องนั้นๆ

  this.http.post('http://192.168.1.11:5555/open',{token: data}).subscribe(res =&amp;gt; {
    console.log('register send');
  });

ส่ง token ไปที่ server ของเราเพื่อบันทึกข้อมูลหรืออะไรก็ว่าไป

pushObject.on('notification').subscribe(
    notification =&amp;gt; {
    alert('You are in app');
});

เป็น event ที่เกิดขึ้นเมื่อได้รับการแจ้งเตือนจาก server เพียงแค่นี้เป็นอันเรียบร้อยโรงเรียนเตรียมแล้วจ้าทดสอบรันแอพด้วยคำสั่ง

ionic run android


ผลลัพท์เมื่อรันแอพ
เมื่อแอพเริ่มทำงานจะมีการ alert แบบนี้ปรากฎขึ้นมาแบบนี้

token ของแอพที่แสดงใน server
ส่วนใน server จะแสดง token ของเราที่ได้รับมาจากแอพให้ก๊อป token มาใส่ใน route /send แบบข้างล่างนี้

...
app.get('/send', (req, res) =&amp;gt; {
  let token = 'fF6tMEynuYg:APA91bH8phSueoBfdOVMchBvBaxyyJVx4fe5msoZVbGAwLqAf...'; //token
  ...
})

หลังจากนั้นให้ลองออกจากแอพแล้วเปิด Browser ไปที่พาท http://localhost:5555/send จะมีแจ้งเตือนขึ้นดังภาพ

เย้ๆ มีแจ้งเตือนแล้วจ้า

Conclution

เพียงเท่านี้ก็เสร็จแล้วจ้าสำหรับการแจ้งเตือนในบทความนี้ยังเป็นพื้นฐานมากๆ นะครับเพื่อนๆต้องเอาไปปรับปรุงต่อเพื่อนำมาใช้จริงต่อไปนะจ๊ะ
ศึกษาเพิ่มเติม
    
        Ionic2
        Firebase
    

สำหรับ Code บน git ก็แปะไว้ก่อนเหมือนเดิมนะครับเพราะช่วงนี้ผมงานเยอะมากๆเลยอ่ะ = =&quot;
</content>
      <categories>
        
          <category> mobile </category>
        
      </categories>
      <tags>
        
          <tag> node.js </tag>
        
          <tag> ionic framework </tag>
        
          <tag> Typescript </tag>
        
          <tag> javascript </tag>
        
          <tag> firebase </tag>
        
          <tag> Angular </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>วิธีการใช้งาน Cordova Plugin ใน Ionic2</title>
      <url>/mobile/2017/03/23/how-to-use-cordovar-in-ionic2/</url>
      <content type="text">
สวัสดีครับเนื่องจากช่วงนี้งานเยอะมากๆเลย วันนี้เลยขอเขียน How To สั้นๆแต่คิดว่าน่าจะมีประโยชน์สำหรับคนที่ใช้งาน Ionic2 ไม่มากก็น้อยนะครับ

Problem

สำหรับคนที่เขียน Hybrid Application ไม่ว่ามือใหม่หรือมือเก๋าก็น่าจะรู้กันดีอยู่แล้วนะครับว่าตัว Javascript ของเราเนี่ยไม่สามารถเข้าถึง Hardware ของเครื่องได้ตรงๆ เหมือนพวก Native Application เพราะฉะนั้นเราจึงต้องใช้ตัวกลางที่เรียกว่า Cordova (ถ้าค่าย Adobe จะเรียกว่า PhoneGAP) ซึ่งเป็น Plugin ที่มีคนเขียนไว้ให้เข้าถึง Hardware ของเครื่องมีให้เลือกใช้งานหลากหลาย แต่ทว่าเหมือนบุญมีแต่กำบังด้วยความที่ Ionic2 ล้ำจัดดันทะลึ่งใช้ TypeScript แทน Javascript ล่ะไอ้ Typescript เนี่ยดันทะลึ่งไม่รู้จักพวก Browser Object บ้างตัวอีกเช่น window screen ทำให้พอเรียกใช้ใน TypeScript ก็จะ error นั่นเองนะจ๊ะ

Javascript ไม่สามารถเข้าถึง Hardware ตรงๆได้ต้องอาศัย Cordovar (PhoneGAP) เข้าถึง Hardware

Fix it


มันคือไรอ่ะหนูไม่รู้จัก T^T
ถ้าเจอปัญหาแบบในรูปข้างต้นนะครับสรุปวิธีแก้ง่ายๆเลยนะครับประกาศสิ่งที่มันต้องการในไฟล์ที่จะใช้งานหลัง import ซ่ะเช่น ในรูปข้างบนจะเห็นว่ามันไม่รู้จัก screen.orientation ก็แนะนำให้มันรู้จักซ่ะ เช่น

import ...

declare var screen:any;

...

เป็นอันเรียบร้อยนะจ๊ะพอลองรันอีกครั้งจะเห็นว่าเขียวแล้วหลังจากนั้นก็เขียน Code ได้ตามปกตินะจ๊ะ

ไม่งอแงแล้วนะจ๊ะ

Conclusion


ติดตั้ง Cordovar Plugin ที่ต้องการใช้งาน
ประกาศสิ่งที่มันต้องการตามตัวอย่างข้างบน
เขียน Code อย่างมีความสุข

ศึกษาเพิ่มเติม Cordova

หมายเหตุ บทความนี้ใช้กับ Library ของ Javascript ที่จะใช้งานบน Angular ก็ได้นะจ๊ะ

</content>
      <categories>
        
          <category> mobile </category>
        
      </categories>
      <tags>
        
          <tag> ionic framework </tag>
        
          <tag> Typescript </tag>
        
          <tag> javascript </tag>
        
          <tag> Angular </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>วิธีทำแอพแชทง่ายๆ ด้วย Ionic2</title>
      <url>/mobile/backend/2017/03/18/ionic-chat/</url>
      <content type="text">
เบื่อไหมครับที่เวลาจะเขียนแอพขึ้นมาซักแอพหนึ่งเนี่ยต้องนั่งทำทั้ง Android iOS ไหนจะต้องเรียนรู้ภาษาใหม่ๆ ทั้ง Java Swift โหยลำบากวุ่นวายอ่ะ แล้วทำไมกูต้องไปเรียนรู้ภาษาใหม่ๆด้วยว่ะครับ ทั้งๆ ที่กูก็เขียบเว็ปเป็นอยู่แล้วทำไมจะเอาพวก Javascript CSS HTML มาทำแอพไม่ได้!! แต่ช้าก่อนนี่มันโลกยุค 2017 แล้วนะจ๊ะ TV Direct ขอนำเสนอ Ionic2 !

สมัยก่อนการทำแอพขึ้นมาซักแอพนึงเนี่ยต้องทำทั้ง iOS และ Android แต่เดี๋ยวนี้ไม่ต้องแล้ว

What is Ionic2

Ionic2 คือเครื่องมือที่ทำให้เราสามารถเขียนแอพเพียงครั้งเดียวสามารถทำงานได้ทุก Platform (หรือที่เรียกแบบเกร๋ๆ ว่า Cross Platform) โดยใช้แค่ Javascript CSS HTML ในการเขียนโปรแกรมซึ่งการทำงานของ Ionic2 ก็คือตัว Ionic2 จะทำตัวเป็นเหมือน Browser ที่แสดงเฉพาะเว็ปๆ เดียวก็คือเว็ปที่เราเขียนขึ้นมานั่นเองซึ่งเราจะเรียกแอพที่ทำงานในลักษณะนี้ว่า Hybrid App หลายคนอ่านมาถึงตรงนี้อาจจะคิดว่ามันก็คือเว็ปธรรมดาก็ไม่เหมือนแอพจริงๆ สิ ผมขอบอกตรงนี้นะครับนี่มันโลกยุคไหนแล้วถ้าไม่มีคนบอกผมนั่งยันนอนยันตะแคงข้างยันเลยว่ายังไงก็ดูไม่ออกเอาล่ะโม้มาเยอะแล้วมาเริ่มกันเถอะ
Javascript ที่ Ionic2 ใช้คือ Angular2 นะครับ

Required &amp;amp; Install

สิ่งที่ต้องการสำหรับใช้งาน


    พื้นฐาน Node.js นิดหน่อย (อีกแล้วครับท่าน)
    Node.js เวอร์ชันล่าสุด
    Android Studio เพราะว่าเราต้องการตัว Android SDK นะจ๊ะถ้าใครไม่มีสามารถดาวโหลดได้ ที่นี่ (จริงๆแล้วดาวโหลดแค่ SDK tool ก็ได้แต่ว่าผมว่าลง Android Studio ไปเลยจะเวิร์คกว่า)
    Geanymotion เป็น emulator ทดสอบแอพของเรานะครับถ้าใครไม่มีสามารถดาวโหลดได้ ที่นี่
    Ionic2 ติดตั้งสามารถด้วยคำสั่งนี้ npm install -g cordova ionic
    ในบทความนี้จะไม่ลงรายละเอียดถึงตัว Angular2 เยอะนะครับควรจะศึกษามาบ้างเล็กน้อยเพื่อความเข้าใจ


Start Server

เมื่อเรามีสิ่งที่ต้องหมดแล้วต่อมาก็มาเริ่มกันเถอะ โดยเราจะเริ่มจากทำฝั่ง Server ก่อนนะจ๊ะ

    mkdir ionic-chat
    cd ionic-chat
    npm init
    npm install socket.io express --save

socket.io สำหรับรับส่งข้อความแบบ real time ส่วน express ใช้เป็น server (จริงๆไม่ต้องใช้ก็ได้แต่ผมขี้เกียจเขียนเองอ่ะมีไรป่ะ) เมื่อทำเสร็จแล้วให้สร้างไฟล์ index.js ขึ้นมาโดยใส่ Code ข้างล่างนี้ลงไป
index.js

const express = require('express');
const app = express();
const server = require('http').createServer(app);
const io = require('socket.io').listen(server);
app.use((req, res, next) =&amp;gt; {
    res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);
    res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;Origin, X-Requested-With, Content-Type, Accept&quot;);
    next();
});
app.get('/', (req, res) =&amp;gt;{
    res.send('This is ma awesome server');
});
io.on('connection', (client) =&amp;gt; {
    console.log('Client connected...');
    client.on('msg', (message) =&amp;gt; {
        io.emit('msg', message);
    });
});
server.listen(5555, () =&amp;gt; {
    console.log('Program running on port : 5555');
});

แค่นี้เหลาะครับสำหรับฝั่ง Server ของเราเป็นอันเรียบร้อยอธิบาย Code นะครับ

const express = require('express');
const app = express();
const server = require('http').createServer(app);
const io = require('socket.io').listen(server);

เรียกใช้และสร้าง server โดยใช้ express และผูก Socket.io ไว้กับ server ที่ถูกสร้างขึ้น

app.use((req, res, next) =&amp;gt; {
    res.header(&quot;Access-Control-Allow-Origin&quot;);
    res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;Origin, X-Requested-With, Content-Type, Accept&quot;);
    next();
});

เซ็ท Header ให้เรียกใช้จาก server อื่นได้

app.get('/', (req, res) =&amp;gt;{
    res.send('This is ma awesome server');
});

เซ็ท route สำหรับคนที่เข้ามาใน server ผ่านทาง browser 

io.on('connection', (client) =&amp;gt; {
  ...
});

เป็น event ที่จะเกิดขึ้นเมื่อมีผู้ใช้เชื่อมต่อเข้ามาในท่อ

client.on('msg', (message) =&amp;gt; {
  ...
});

เป็น event ที่จะเกิดขึ้นเมื่อผู้ใช้ส่งข้อมูลเข้ามาผ่านท่อที่ชื่อว่า msg

io.emit('msg', message);

ส่ง msg ที่ได้รับให้ผู้ใช้ทุกคน

ถ้าหากต้องการส่งให้ทุกคนยกเว้นตัวคนส่งเองให้ใส่เป็น

client.broadcast.emit('msg', message);

แต่ถ้าต้องการส่งกลับไปให้คนส่งคนเดียวเท่านั้น(แล้วจะเรียกว่า chat ไหมหนอ) ให้ใส่เป็น

client.emit('msg', message);



server.listen(5555, () =&amp;gt; {
    console.log('Program running on port : 5555');
});

เริ่มต้นการทำงานของ server ที่ port 5555 ด้วยคำสั่ง
node index.js
เมื่อทดลองเข้าผ่านหน้าเว็ปไปที่ http://localhost:5555 จะได้หน้าตาดังภาพข้างล่างนี้

ทดลองรัน server ผ่าน Browser

Start Ionic2

เอาล่ะครับน่าจะถึงเวลาที่ทุกคนรอคอยได้เขียนแอพจริงๆซักที 5555 เริ่มด้วยคำสั่ง

ionic start ionic-chat-client blank --v2
cd ionic-chat-client

เข้ามาจะเห็นไฟล์อะไรเยอะแยะเลยนะครับไม่ต้องตรงใจในตอนนี้เราสนใจแค่ในโฟรเดอร์ src ก็พอเมื่อเข้ามาจะเห็นว่าโครงสร้างมันคล้ายๆเว็ปไซด์เลยให้เปิดไฟล์ index.html ขึ้นมาหลังจากนั้นให้เพิ่มโหลด script นี้เข้าไป

&amp;lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/socket.io/1.7.3/socket.io.js&quot;&amp;gt;&amp;lt;/script&amp;gt;

เข้าไปที่ Page/home/home.html และแก้ไข Code ให้เป็นดังนี้

&amp;lt;ion-header&amp;gt;
  &amp;lt;ion-navbar&amp;gt;
    &amp;lt;ion-title&amp;gt;
      Ionic Blank
    &amp;lt;/ion-title&amp;gt;
  &amp;lt;/ion-navbar&amp;gt;
&amp;lt;/ion-header&amp;gt;

&amp;lt;ion-content padding&amp;gt;
  &amp;lt;ion-card *ngFor=&quot;let msg of massage&quot;&amp;gt;
    &amp;lt;ion-card-content&amp;gt;
      {{ msg }}

    &amp;lt;/ion-card-content&amp;gt;
  &amp;lt;/ion-card&amp;gt;
&amp;lt;/ion-content&amp;gt;

&amp;lt;ion-footer&amp;gt;
  &amp;lt;ion-toolbar&amp;gt;
    &amp;lt;ion-item&amp;gt;
      &amp;lt;ion-label fixed&amp;gt;Massage: &amp;lt;/ion-label&amp;gt;
      &amp;lt;ion-input type=&quot;text&quot; [(ngModel)]=&quot;msg&quot;&amp;gt;&amp;lt;/ion-input&amp;gt;
    &amp;lt;/ion-item&amp;gt;
    &amp;lt;ion-buttons end (click)=&quot;send()&quot;&amp;gt;
      &amp;lt;button ion-button icon-right color=&quot;royal&quot;&amp;gt;
        Send
        &amp;lt;ion-icon name=&quot;send&quot;&amp;gt;&amp;lt;/ion-icon&amp;gt;
      &amp;lt;/button&amp;gt;
    &amp;lt;/ion-buttons&amp;gt;
  &amp;lt;/ion-toolbar&amp;gt;
&amp;lt;/ion-footer&amp;gt;

จาก Code ข้างบนจะมีจุดสังเกตุ 3 จุดดังนี้

&amp;lt;ion-card *ngFor=&quot;let msg of massage&quot;&amp;gt;
    &amp;lt;ion-card-content&amp;gt;
      {{ msg }}
    &amp;lt;/ion-card-content&amp;gt;
&amp;lt;/ion-card&amp;gt;

*ngFor=&quot;...&quot; คือการสั่งให้วนลูปของ Angular2 ส่วน {{ msg }} คือการแสดงค่า Object ของ Angular2 หรือเรียกว่า Two-way binding (จะไว้อธิบายในบทความต่อๆไปนะครับ) และส่วนสุดท้าย (click)=&quot;send()&quot; คือการควบคุม event click นะครับถ้าเป็น Javascript ธรรมดาก็อารมณ์ Onclick ประมาณนั้น
รันจากนั้นเมื่อทดสอบรันด้วยคำสั่ง ionic serve ionic จะทำการเปิด Browser ขึ้นมาและจะได้หน้าตาเปล่าๆ ประมาณนี้นะครับ

ทดสอบรันแอพผ่าน Browser
ต่อมาให้เราเปิดไฟล์ Page/home/home.ts ขึ้นมาและแก้ไขให้เป็นดังนี้นะครับ

import { Component } from '@angular/core';

import { NavController } from 'ionic-angular';

declare var io;

@Component({
  selector: 'page-home',
  templateUrl: 'home.html'
})
export class HomePage {

  socketHost: string;
  socket: any;
  massage: any;
  msg: string;
  constructor(public navCtrl: NavController) {
    this.socketHost = &quot;http://localhost:5555&quot;;
    this.massage = [];
    this.socket = io(this.socketHost);
    this.socket.on(&quot;msg&quot;, (msg) =&amp;gt; {
      this.massage.push(msg);
    });
  }

  send(){
    this.socket.emit(&quot;msg&quot;, this.msg);
    this.msg = &quot;&quot;;
  }

}

อธิบาย Code นะครับ

declare var io;

คือการประกาศตัวแปร io นะครับจริงๆไม่ต้องประกาศก็ได้แต่ตัว Typescript ไม่รู้จัก io เลยต้องประกาศไม่งั้นจะงอแงเอา

  socketHost: string;
  socket: any: any;
  massage: string[];
  msg: string;

ประกาศตัวแปลสำหรับเก็บค่าต่างๆ นะครับ 

socketHost เป็น string เก็บ url ของ server
socket สำหรับเก็บ socket นะครับไม่รู้จะให้ type อะไรเลยใส่เป็น any (any คือท่าไม้ตายคิด type ไม่ออก any ไปก่อน 555)
massage สำหรับเก็บข้อความที่ chat ไปมาเป็น string array
msg สำหรับเก็บข้อความจากช่อง input เป็น string


this.socketHost = &quot;http://localhost:5555&quot;;
this.massage = [];

กำหนดค่าสำหรับตัวแปลต่างๆ

this.socket = io(this.socketHost);

สร้าง socket ขึ้นมา

this.socket.on(&quot;msg&quot;, (msg) =&amp;gt; {
  this.massage.push(msg);
});

เมื่อได้รับข้อความจาก server ผ่านทางท่อ msg ให้ push ใส่ array massage

send(){
    this.socket.emit(&quot;msg&quot;, this.msg);
    this.msg = &quot;&quot;;
  }

ส่งข้อความไปให้ server ผ่านทางท่อ msg แค่นี้เหลาะครับเสร็จแล้วหลังจากนั้นลองดูที่ terminal ที่รัน server ของเราถ้าขึ้นว่า Client connected... ดังภาพเป็นอันเรียบร้อยโรงเรียนเตรียม 

มีการเชื่อมต่อจาก client สู่ server
ลองเปิด Browser ไปที่ http://localhost:8100 2 หน้าต่างและทดสอบใช้จะได้ผลลัพท์ดังภาพ

แชทได้แล้วจ้า
สำหรับใครที่ต้องการทดสอบบน emulator ให้เปิด geanymotion และเปลี่ยน socketHost ไป ip เครื่องตัวเองเช่น

this.socketHost = &quot;192.168.1.28:5555&quot;;

และทดสอบรันด้วยคำสั่งข้างล่างนี้ก็เป็นเรียบร้อย

ionic platform add android
ionic run android


Conclusion

ศึกษาเพิ่มเติม

    Ionic2
    socket.io

สำหรับ Code บน git แปะไว้ก่อนนะครับเพราะตอนที่เขียนบทความนี้ดึกมากแล้วง่วงมักๆ ถ้าไม่ลืมจะตามมาอัพให้นะครับ
</content>
      <categories>
        
          <category> mobile </category>
        
          <category> backend </category>
        
      </categories>
      <tags>
        
          <tag> node.js </tag>
        
          <tag> ionic framework </tag>
        
          <tag> Typescript </tag>
        
          <tag> javascript </tag>
        
          <tag> firebase </tag>
        
          <tag> Angular </tag>
        
          <tag> socket.io </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>แจ้งเตือนการทำงานของ Server แบบ Low cost ด้วย Line Notify</title>
      <url>/server/backend/2017/03/17/line-notify/</url>
      <content type="text">
หลายคนคงจะทราบกันอยู่แล้วนะครับว่า Line ได้เปิดตัวบริการใหม่คือ Line Notify เมื่อไม่นานที่ผ่านมา
ซึ่งตัวไลน์ Notify เนี่ยจะแตกต่างกัน Line Bot ตรงที่ว่าจะตอบเราไม่ได้ และเวลาจะใช้ก็ต้องเชิญเข้า Group ก่อน
ซึ่งประโยชน์ของมันคือใช้สำหรับติดตามดูความเคลื่อนไหวของ service หรือ server ของเราก็ได้ ซึ่ง Line ก็มี Partner สำหรับบริการเราชื่อ Mackerel แต่ประเด็อคือมันเสียตังน่ะสิ (= =&quot;) ซึ่งแน่นอนว่าโปรแกรมเมอร์สายประหยัดอย่างเราไม่ยอมเสียเงินแน่นอน 555+ เพราะฉะนั้นเรามาเขียนเองกันดีกว่า

Required &amp;amp; Install

สิ่งที่ต้องการในการ Monitor เซิฟเวอร์แบบ Low Cost ของเรามีดังนี้

    ID Line เชื่อว่าทุกคนคงจะมีอยู่แล้วนะครัคงไม่สอนสมัคร (= =&quot;)
    กลุ่มไลน์ที่ต้องการให้ส่งข้อความ (ตรงนี้แล้วแต่นะ)
    ความรู้ Node.js (จริงๆใช้อะไรเขียนก็ได้แต่ผมชอบ Node.js อ่ะมีไรป่ะ)


Start

ขั้นตอนแรกให้เราเข้าสู่เว็ปไซด์ Line Notify และ Login ให้เรียบร้อยหลังจากนั้นกดที่ My Page ตามภาพ

เมนู My Page จะปรากฏเมื่อคลิ๊กที่ชื่อไลน์ของคุณ
เลื่อนลงมาข้างล่างจะเห็นคำว่า Generate Token คลิ๊กโลดเมื่อคลิ๊กแล้วจะขึ้นหน้าตาดังภาพข้างล่างให้กรอกรายละเอียดให้เรียบร้อยในกรณีที่ต้องการให้ส่งข้อความให้เฉพาะตัวเองให้เลือก 1-on-1 chat

เลือก 1-on-1 chat ถ้าอยากคุยคนเดียว
เมื่อสร้างเสร็จจะได้ Token มาหนึ่งอันให้ก๊อบปี้เก็บไว้ก่อน (อย่าทำหายล่ะ!) ต่อมาเรามาเริ่มเขียนโค้ดเพื่อส่งการแจ้งเตือนกันเถอะทำตามคุณครูนะค่ะเด็กๆ

    mkdir monitor-server
    cd moniter-server
    npm init
    npm install monitor request --save


    monitor ใช้สำหรับติดตามการทำงานของ server
    request ใช้สำหรับส่ง request ไปยัง Line Notify (จริงๆ เขียนเองก็ได้แต่ขี้เกียจ 555)

ต่อมาสร้างไฟล์ index.js และใส่ Code ข้างล่างลงไป
index.js

const Monitor = require('monitor');
const request = require('request')
const LOW_MEMORY_THRESHOLD = 100000000;
const token = 'token';

var options = {
  probeClass: 'Process',
  initParams: {
    pollInterval: 10000
  }
}
var processMonitor = new Monitor(options);

processMonitor.on('change', () =&amp;gt; {
  var freemem = processMonitor.get('freemem');
  var msg = &quot;Your Free memory Left &quot;+freemem;
  request({
     method: 'POST',
     uri: 'https://notify-api.line.me/api/notify',
     headers: {
       'Content-Type': 'application/x-www-form-urlencoded',
  },
     'auth': {
       'bearer': token
  },form: {
       message: msg,
    }
  }, (err,httpResponse,body) =&amp;gt; {
     console.log(JSON.stringify(err));
     console.log(JSON.stringify(httpResponse));
     console.log(JSON.stringify(body));
  })
});

processMonitor.connect((error) =&amp;gt; {
  if (error) {
    console.error('Error connecting with the process probe: ', error);
    process.exit(1);
  }
});

อธิบาย Code

const Monitor = require('monitor');
const request = require('request')
const LOW_MEMORY_THRESHOLD = 100000000;
const token = 'token';

เรียกใช้งาน Module Monitor และ request ตั้งค่าแรมที่น้อยที่สุดหากน้อยกว่านี้ให้แจ้งเตือนใส่ token เตรียม (อย่าลืมใส่ token ของคุณล่ะ)

var options = {
  probeClass: 'Process',
  initParams: {
    pollInterval: 10000
  }
}
var processMonitor = new Monitor(options);

เซ็ท Option สำหรับ Monitor และให้วนเช็คทุกๆ 10000 milliseconds และสร้างการ Monitor ใหม่

processMonitor.on('change', () =&amp;gt; {
  var freemem = processMonitor.get('freemem');
  var msg = &quot;Your Free memory Left &quot;+freemem;
  request({
     method: 'POST',
     uri: 'https://notify-api.line.me/api/notify',
     headers: {
       'Content-Type': 'application/x-www-form-urlencoded',
  },
     'auth': {
       'bearer': token
  },form: {
       message: msg,
    }
  }, (err,httpResponse,body) =&amp;gt; {
     console.log(JSON.stringify(err));
  })
});

เมื่อสถานะของ Monitor เปลี่ยนจะเข้า event change ให้ดึงจำนวนแรมที่เหลือ และส่ง request ไปที่ Line Notify โดยฝัง token ไปกับ  Header และส่งข้อความที่สร้างขึ้นไปด้วย ซึ่งจะเห็นว่าจริงๆแล้ว Line Notify เนี่ยแค่ request ไปให้ถูกก็พอไม่จำเป็นต้องติดตั้ง Library อะไรของ Line เพิ่มเติมพิเศษเลย
Line Notify แค่ส่ง request ไปให้ถูกก็พอไม่จำเป็นต้องไปติดตั้ง Library ให้วุ่นวาย

processMonitor.connect((error) =&amp;gt; {
  if (error) {
    console.error('Error connecting with the process probe: ', error);
    process.exit(1);
  }
});

ให้แสดง error และปิดโปรแกรมหากไม่สามารถดึงข้อมูลมาได้ เมื่อโค้ดเสร็จแล้วก็มาทำสอบกันด้วยคำสั่ง
node index.js
จะเห็นว่ามีไลน์ขึ้นมาดังภาพ

รันปุ๊บขึ้นปั๊บ ถ้าไม่รับปั๊บก็คงไม่ขึ้นปุ๊บ
ต่อมาจะเห็นว่าตอนนี้มันแจ้งเตือนบ่อยจนหน้ารำคาญให้เราปรับปปรุง Code ใน change event เป็นดังนี้

processMonitor.on('change', () =&amp;gt; {
  var freemem = processMonitor.get('freemem');
  if (freemem &amp;lt; LOW_MEMORY_THRESHOLD) {
    var msg = 'Low memory warning: ' + freemem;
    request({
         method: 'POST',
         uri: 'https://notify-api.line.me/api/notify',
         headers: {
           'Content-Type': 'application/x-www-form-urlencoded',
         },
         'auth': {
           'bearer': token
         },form: {
           message: msg,
         }
    }, (err,httpResponse,body) =&amp;gt; {
         console.log(JSON.stringify(err));
    })
}
});

Conclusion

เพียงเท่านี้เราก็จะได้รับการแจ้งเตือนเมื่อแรมเราเหลือน้อยกว่าที่เรากำหนดไว้แล้วล่ะครับสำหรับคนที่ต้องการตรวจสอบอย่างอื่นเช่น CPU, heapTotal, heapUsed สามารถดูได้ ที่นี่
สำหรับคนที่ต้องการใช้ฟังชันอื่นๆของ Line Notify สามารถดูได้ ที่นี่
สามารถดาวโหลด Code ได้ที่นี่ Github
</content>
      <categories>
        
          <category> server </category>
        
          <category> backend </category>
        
      </categories>
      <tags>
        
          <tag> node.js </tag>
        
          <tag> line-notify </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>สอนวิธีใช้งาน Selenium เบื้องต้น</title>
      <url>/testing/2017/03/16/selenium-EP-01/</url>
      <content type="text">
ในการจะทดสอบการทำงานของเว็ปไซด์ซักเว็ปหนึ่งเนี่ยเป็นเรื่องที่เหนื่อยและสิ้นเปลืองพลังงานชีวิตมากมายเลยนะครับ ยิ่งถ้าเป็นเว็ปไซด์ใหญ่ๆมีลิงค์มีปุ่มให้กดเยอะแยะด้วยแล้วยิ่งไม่ต้องสืบว่าจะใช้เวลานานซักแค่ไหน ดังนั้นจะดีแค่ไหนถ้าเราสามารถเขียน Bot ขึ้นมาเพื่อให้สามารถตรวจสอบการทำงานของเว็ปไซดโดยที่เราไม่ต้องทำอะไรเลยนั่งจิ๊บกาแฟชิลๆ อิอิ

โปรแกรมเมอร์ที่เก่งคือโปรแกรมเมอร์ที่ขี้เกียจ ปล. ขี้เกียจในทางที่ดีนะ

เชื่อไหมครับว่าไม่ได้มีแต่เราที่ขี้เกียจใครๆ เขาก็ขี้เกียจกันทั้งนั้น (= =&quot;) แบบนี้จึงมีคนพัฒนาสิ่งที่เรียกว่า Selenium Webdriver ขึ้นเจ้า Selenium เนี่ยถ้าว่าง่ายๆก็คือ บอทสำหรับทดสอบการทดงานของเว็ปไซด์นั่นเอง

Required &amp;amp; Install

ในการใช้ Selenium มีสิ่งที่ต้องการดังนี้

    
    พื้นฐาน Node.js นิดหน่อย (จริงๆ ตัว Selenium เขียนได้กับหลายภาษาเช่น Java, Python แต่ผมชอบ Node.js อ่ะมีไรป่ะ)
    Node.js เวอร์ชันล่าสุด Download
    Chrome Webdriver สำหรับ window สามารถดาวโหลดได้ ที่นี่ 
    Chrome Webdriver สำหรับ Mac สามารถติดตั้งโดยใช้ Homebrew ได้ใครไม่มีสามารถดาวโหลดได้ ที่นี่ เมื่อติดตั้ง Homebrew เสร็จแล้วให้พิมพ์คำสั่งนี้ brew install chromedriver
    Chrome Webdriver สำหรับ Linux สามารถติดตั้งโดยใช้คำสั่งนี้ sudo apt-get install unzip;
wget -O /tmp/chromedriver.zip http://chromedriver.googlecode.com/files/chromedriver_linux64_19.0.1068.0.zip 
&amp;amp;&amp;amp; sudo unzip /tmp/chromedriver.zip chromedriver -d /usr/local/bin/;

    


Start

เมื่อเราทำการติดตั้ง และดาวโหลดสิ่งที่ต้องการมาแล้วก็มาเริ่มกันเถอะเปิด Terminal ขึ้นมาและพิมพ์คำสั่งตามนี้นะจ๊ะเด็กๆ

mkdir selenium-ep01
cd selenium-ep01
npm init
npm install selenium-webdriver --save


เมื่อดำเนินการเสร็จแล้วสำหรับผู้ใช้ window ให้ลากไฟล์ webdriver ที่ดาวโหลดมามาใส่ สำหรับคนใช้ Mac กับ Linux ไม่ต้องนะจ๊ะ อิอิ ต่อมาเปิด Text editor สร้างไฟล์ชื่อ index.js ขึ้นมาแล้วใส่คำสั่งตามนี้

index.js

var webdriver = require('selenium-webdriver'),
    By = webdriver.By,
    until = webdriver.until;

var driver = new webdriver.Builder()
    .forBrowser('chrome')
    .build();

driver.get('http://www.google.com/ncr');
driver.findElement(By.name('q')).sendKeys('webdriver');
driver.findElement(By.name('btnG')).click();
driver.wait(until.titleIs('webdriver - Google Search'), 1000);

อธิบาย Code

var webdriver = require('selenium-webdriver'),
    By = webdriver.By,
    until = webdriver.until;

ดึง Module ของ selenium-webdriver มาใช้และ Module อื่นๆที่จำเป็นมาใช้
    
        By ใช้เข้าถึง Element ต่างๆในหน้าเว็ป
        until เพื่อรอการทำงานของ Browser



var driver = new webdriver.Builder()
    .forBrowser('chrome')
    .build();

สร้าง driver สำหรับ Google Chrome (สั่งให้เปิด Browser)

driver.get('http://www.google.com/ncr');

เปิด Browser ไปที่ url https://www.google.com/ncr

driver.findElement(By.name('q')).sendKeys('webdriver');

หา Element ที่ attribute name ว่า q (ช่อง input) และใส่ค่าว่า webdriver

driver.findElement(By.name('btnG')).click();

หา Element ที่ attribute name ว่า btnG (ปุ่มค้นหา) และคลิ๊ก

driver.wait(until.titleIs('webdriver - Google Search'), 1000);

รอจน title ของเว็ปขึ้นว่า 'webdriver - Google Search' เป็นอันเสร็จสิ้นกระบวนความรันด้วยคำสั่ง
node index.js
เมื่อรันเสร็จจะได้ผลดังภาพ

ค้นหา Google ด้วย Selenium

Conclusion

ศึกษาเพิ่มเติม Selenium API
สามารถดาวโหลด Code ได้ที่นี่ Github
</content>
      <categories>
        
          <category> testing </category>
        
      </categories>
      <tags>
        
          <tag> node.js </tag>
        
          <tag> automate test </tag>
        
          <tag> selenium </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
</search>
